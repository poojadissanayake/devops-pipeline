name: CD - Production (CI/CD)

on:
  workflow_run:
    # debugging trigger issue
    workflows: ["*"]
    types:
      - completed
jobs:
  deploy_prod:
    name: Deploy to Production
    # only run when the E2E workflow finished successfully
    if: >
      github.event_name == 'workflow_run' &&
      github.event.workflow_run.name == 'E2E - Playwright on Staging' &&
      github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Debug event payload
        run: |
          echo "WORKFLOW NAME: ${{ github.event.workflow_run.name }}"
          echo "CONCLUSION: ${{ github.event.workflow_run.conclusion }}"
          echo "HEAD BRANCH: ${{ github.event.workflow_run.head_branch }}"
          echo "HEAD SHA: ${{ github.event.workflow_run.head_sha }}"
          echo "REPO: ${{ github.repository }}"
      - name: Checkout repo
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}

      - name: Azure login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: ACR login
        run: az acr login --name ${{ secrets.PROD_AZURE_CONTAINER_REGISTRY }}

      - name: Build and push Product Service
        run: |
          ACR=${{ secrets.PROD_AZURE_CONTAINER_REGISTRY }}.azurecr.io
          docker build -t $ACR/product_service:latest ./backend/product_service
          docker push $ACR/product_service:latest

      - name: Build and push Order Service
        run: |
          ACR=${{ secrets.PROD_AZURE_CONTAINER_REGISTRY }}.azurecr.io
          docker build -t $ACR/order_service:latest ./backend/order_service
          docker push $ACR/order_service:latest

      - name: Build and push Customer Service
        run: |
          ACR=${{ secrets.PROD_AZURE_CONTAINER_REGISTRY }}.azurecr.io
          docker build -t $ACR/customer_service:latest ./backend/customer_service
          docker push $ACR/customer_service:latest

      - name: Build and push Frontend
        run: |
          ACR=${{ secrets.PROD_AZURE_CONTAINER_REGISTRY }}.azurecr.io
          docker build -t $ACR/frontend:latest ./frontend
          docker push $ACR/frontend:latest

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group "${{ vars.PROD_AKS_RESOURCE_GROUP }}" \
            --name "${{ vars.PROD_AKS_CLUSTER_NAME }}" \
            --overwrite-existing
          kubectl cluster-info

      # backend infrastructure
      - name: Apply backend infrastructure manifests
        run: |
          cd k8s-prod
          kubectl apply -f configmaps.yaml
          kubectl apply -f secrets.yaml
          kubectl apply -f product-db.yaml
          kubectl apply -f order-db.yaml
          kubectl apply -f customer-db.yaml
          kubectl apply -f rabbitmq.yaml

      # Inject Storage creds into ecommerce-secret for product-service
      - name: Ensure storage keys are in ecommerce-secret
        shell: bash
        run: |
          set -e
          NS=default
          SA_NAME='${{ secrets.PROD_STORAGE_ACCOUNT_NAME }}'
          if [ -z "$SA_NAME" ]; then
            echo "Missing PROD_STORAGE_ACCOUNT_NAME secret"; exit 1
          fi

          SA_KEY='${{ secrets.PROD_STORAGE_ACCOUNT_KEY }}'

          if [ -z "$SA_KEY" ]; then
            echo "No PROD_STORAGE_ACCOUNT_KEY provided; discovering RG and fetching a key..."
            SA_RG=$(az storage account show -n "$SA_NAME" --query resourceGroup -o tsv)
            if [ -z "$SA_RG" ]; then
              echo "Could not discover RG for storage account $SA_NAME"; exit 1
            fi
            SA_KEY=$(az storage account keys list -g "$SA_RG" -n "$SA_NAME" --query "[0].value" -o tsv)
            if [ -z "$SA_KEY" ]; then
              echo "Failed to retrieve storage key for $SA_NAME"; exit 1
            fi
          fi

          # patch the secret with storage account name and key
          kubectl -n "$NS" patch secret ecommerce-secret \
            --type merge \
            -p "{\"stringData\":{
              \"AZURE_STORAGE_ACCOUNT_NAME\":\"$SA_NAME\",
              \"AZURE_STORAGE_ACCOUNT_KEY\":\"$SA_KEY\"
            }}"

      # all services
      - name: Deploy services
        run: |
          cd k8s-prod
          kubectl apply -f product-service.yaml
          kubectl apply -f order-service.yaml
          kubectl apply -f customer-service.yaml
          kubectl apply -f frontend.yaml

      - name: Wait for frontend IP
        id: ip
        run: |
          for i in {1..60}; do
            EP=$(kubectl get svc frontend -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
            if [ -n "$EP" ]; then
              echo "FRONTEND=http://$EP" >> $GITHUB_ENV
              exit 0
            fi
            echo "Waiting for frontend LB IP... ($i/60)"
            sleep 5
          done
          echo "Timeout waiting for frontend IP" >&2
          exit 1

      - name: Run smoke checks
        run: |
          set -e
          echo "Testing frontend at $FRONTEND"
          curl -fsS "$FRONTEND/api/products/"   | head -c 200
          curl -fsS "$FRONTEND/api/orders/"     | head -c 200
          curl -fsS "$FRONTEND/api/customers/"  | head -c 200

      - name: Success message
        run: echo "Production deployment completed successfully!"
